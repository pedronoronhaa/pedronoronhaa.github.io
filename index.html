<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>Postal Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css"/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.awesome-markers/2.0.4/leaflet.awesome-markers.css"/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"/>
<style>
  html, body, #map { height: 100%; margin: 0; }
  .leaflet-control-layers-overlays label { font-weight: 500; }
  .qty-badge { pointer-events: auto; }
</style>
</head>
<body>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.awesome-markers/2.0.4/leaflet.awesome-markers.js"></script>
<script>
  // --- Base map
  var map = L.map('map', { zoomControl: true }).setView([39.5, -8.0], 6);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap'
  }).addTo(map);

  // --- Utilities
  function tFromValue(v, vmin, vmax) {
    if (vmax <= vmin) return 0.5;
    var t = (v - vmin) / (vmax - vmin);
    return Math.max(0, Math.min(1, t));
  }
  function hslGreenToRed(t, lightness) {
    var hue = 120 * (1 - t); // 120=green -> 0=red
    return 'hsl(' + hue.toFixed(0) + ',70%,' + (lightness||40) + '%)';
  }

  // Zoom-aware, log-sized badge (slightly bigger at national view)
  function sizedBadgeHTML(value, smin, smax) {
    var t  = tFromValue(value, smin, smax);
    var bg = hslGreenToRed(t, 40);
    var br = hslGreenToRed(t, 30);

    // Base size by value (gentle log spread)
    var base = Math.round(14 + 7 * Math.log((value||0) + 1)); // px
    base = Math.max(22, Math.min(64, base));                  // clamp base

    // Zoom attenuation:
    // gentler shrink and higher floor so national-view bubbles are a bit bigger
    var z = map.getZoom ? map.getZoom() : 6;
    var zoomScale;
    if (z >= 12) {
      zoomScale = 1.0;
    } else {
      zoomScale = Math.pow(0.90, (12 - z)); // gentler than 0.88
      zoomScale = Math.max(0.62, zoomScale); // bigger floor at far zoom
    }

    var size = Math.round(base * zoomScale);
    size = Math.max(20, Math.min(72, size)); // final clamp

    return {
      html:
        '<div style="background:'+bg+';border:2px solid '+br+';color:white;'
      + 'display:flex;align-items:center;justify-content:center;'
      + 'width:'+size+'px;height:'+size+'px;border-radius:'+(size/2)+'px;'
      + 'font-weight:700;font-size:13px;line-height:1;">'
      + (value||0).toLocaleString() + '</div>',
      size: size
    };
  }

  // --- Lazy layers
  var datasetFiles = {"Nov 2024": "nov_2024.json", "Dec 2024": "dec_2024.json", "Jul 2025": "jul_2025.json"};   // label -> json file
  var dataLayers   = {};        // label -> L.MarkerClusterGroup
  var dataRanges   = {};        // label -> {smin, smax} for resizing on zoom
  var whLayers     = {};        // key   -> L.LayerGroup

  // Cluster icons sized by SUM (same sizing helper)
  function makeClusterIcon(label) {
    return function(cluster) {
      var markers = cluster.getAllChildMarkers();
      var sum = 0;
      for (var i = 0; i < markers.length; i++) {
        var q = parseFloat(markers[i].options.title) || 0;
        sum += q;
      }
      var rng = dataRanges[label] || { smin: 0, smax: Math.max(1, sum) };
      var badge = sizedBadgeHTML(sum, rng.smin, rng.smax);
      return new L.DivIcon({
        html: badge.html,
        className: 'marker-cluster',
        iconSize: new L.Point(badge.size, badge.size)
      });
    };
  }

  function loadDataset(label, url) {
    if (dataLayers[label]) { map.addLayer(dataLayers[label]); return; }
    fetch(url).then(r => r.json()).then(geo => {
      var vals = geo.features.map(f => f.properties.qty_sum || 0);
      var smin = Math.min.apply(null, vals), smax = Math.max.apply(null, vals);
      if (!isFinite(smin) || !isFinite(smax)) { smin = 0; smax = 1; }
      dataRanges[label] = { smin: smin, smax: smax };

      var cluster = L.markerClusterGroup({
        spiderfyOnMaxZoom: true,
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true,
        iconCreateFunction: makeClusterIcon(label)
      });

      geo.features.forEach(f => {
        var q = f.properties.qty_sum || 0;
        var lat = f.geometry.coordinates[1], lon = f.geometry.coordinates[0];

        var badge = sizedBadgeHTML(q, smin, smax);
        var icon  = L.divIcon({
          html: badge.html,
          iconSize: [badge.size, badge.size],
          iconAnchor: [badge.size/2, badge.size/2],
          className: 'qty-badge'
        });

        // Keep title=qty so cluster SUM logic works
        var m = L.marker([lat, lon], { icon: icon, title: String(q) });
        cluster.addLayer(m);
      });

      dataLayers[label] = cluster;
      map.addLayer(cluster);
    });
  }

  // Resize child badges on zoom (clusters re-render automatically)
  function updateBadgeSizes() {
    Object.entries(dataLayers).forEach(function(entry) {
      var label = entry[0], group = entry[1];
      var rng = dataRanges[label] || { smin: 0, smax: 1 };
      if (!group) return;
      group.eachLayer(function(layer) {
        if (layer instanceof L.Marker && layer.options && layer.options.title) {
          var q = parseFloat(layer.options.title) || 0;
          var badge = sizedBadgeHTML(q, rng.smin, rng.smax);
          var icon  = L.divIcon({
            html: badge.html,
            iconSize: [badge.size, badge.size],
            iconAnchor: [badge.size/2, badge.size/2],
            className: 'qty-badge'
          });
          layer.setIcon(icon);
        }
      });
    });
  }
  map.on('zoomend', updateBadgeSizes);

  // --- Warehouses: pins (AwesomeMarkers/PNG fallback)
  function makeWarehouseIcon(color) {
    var hasAwesome = (typeof L.AwesomeMarkers !== 'undefined' && L.AwesomeMarkers.icon);
    if (hasAwesome) {
      var mapped = (color === 'darkblue') ? 'cadetblue' : color; // dark-ish blue
      return L.AwesomeMarkers.icon({
        icon: 'building',
        markerColor: mapped,
        prefix: 'fa'
      });
    } else {
      var iconUrlMap = {
        blue: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
        cadetblue: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-violet.png',
        darkblue: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-violet.png'
      };
      return L.icon({
        iconUrl: iconUrlMap[color] || iconUrlMap.blue,
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
        iconSize: [25,41], iconAnchor: [12,41],
        popupAnchor: [1,-34], shadowSize: [41,41]
      });
    }
  }

  function loadWarehouses(url, color, key) {
    if (whLayers[key]) { map.addLayer(whLayers[key]); return; }
    fetch(url).then(r => r.json()).then(geo => {
      var g = L.layerGroup();
      geo.features.forEach(f => {
        var lat = f.geometry.coordinates[1], lon = f.geometry.coordinates[0];
        var name = f.properties.name || 'Warehouse';
        var pin = L.marker([lat, lon], { icon: makeWarehouseIcon(color) })
                   .bindPopup('<b>Warehouse:</b> ' + name);
        g.addLayer(pin);
      });
      whLayers[key] = g;
      map.addLayer(g);
    });
  }

  // --- Layer control (everything OFF by default)
  var overlays = {
    "Warehouses": L.layerGroup(),
    "New Warehouses": L.layerGroup()
  };
  Object.keys(datasetFiles).forEach(function(lbl) { overlays[lbl] = L.layerGroup(); });

  var control = L.control.layers(null, overlays, { collapsed: false }).addTo(map);

  // tag each overlay with its label so we can detect which was toggled
  Object.entries(overlays).forEach(function(entry) {
    var lbl = entry[0], lg = entry[1];
    lg._label = lbl;
  });

  map.on('overlayadd', function(e) {
    var lbl = e.layer._label;
    if (lbl === 'Warehouses') {
      loadWarehouses('warehouses_existing.json', 'blue', 'existing');
    } else if (lbl === 'New Warehouses') {
      loadWarehouses('warehouses_new.json', 'darkblue', 'new');
    } else if (datasetFiles[lbl]) {
      loadDataset(lbl, datasetFiles[lbl]);
    }
  });

  map.on('overlayremove', function(e) {
    var lbl = e.layer._label;
    if (lbl === 'Warehouses' && whLayers['existing']) map.removeLayer(whLayers['existing']);
    else if (lbl === 'New Warehouses' && whLayers['new']) map.removeLayer(whLayers['new']);
    else if (dataLayers[lbl]) map.removeLayer(dataLayers[lbl]);
  });
</script>
</body>
</html>
